---
title: inputs-from-sdtin
authors:
  - "@oglok"
  - "@copejon"
reviewers:
  - "@fzdarsky"
approvers:
  - "@crawford"
  - "@staebler"
  - "@dgoodwin"
creation-date: 2020-12-24
last-updated: 2021-01-13
status: provisional
---

# Inputs from STDIN

## Release Signoff Checklist

- [ ] Enhancement is `implementable`
- [ ] Design details are appropriately documented from clear requirements
- [ ] Test plan is defined
- [ ] Operational readiness criteria is defined
- [ ] Graduation criteria for dev preview, tech preview, GA
- [ ] User-facing documentation is created in [openshift-docs](https://github.com/openshift/openshift-docs/)

## Summary

In many occasions, users need to customize the install-config target and/or the manifests generated by the OpenShift Installer in a reproducible manner. The most popular tool to allow this type of customization is “Kustomize”, and it is already well-known by the Kubernetes ecosystem. The result of any “Kustomization” is sent to standard output as a stream of manifests.

This OpenShift enhancement proposes to allow the installer to read a stream from STDIN on the main targets that consume inputs.


## Motivation

Infrastructure-as-Code (e.g. GitOps) is an operational best practice for provisioning and managing large numbers of clusters and services. A typical IaC workflow involves pulling Kubernetes resource manifest templates of a specific version from a `git` repo, rendering those templates for a given cluster instance, and then running `openshift-install` (resp. `oc apply`) on the rendered manifests to install (resp. update) a cluster.

Pulling and rendering manifest templates is conveniently done via `kustomize` - which is particularly suited for an IaC workflow - but other tools like `helm` and `jsonnet` have their followers, too. These tools have in common that they render templates into a stream of manifests sent to `stdout`.

As `openshift-install` currently only supports reading manifest files from the file system and requires files to follow a specific naming and directory structure convention, IaC workflows become cumbersome and often involve users writing their own Bash scripts or Ansible playbooks to automate the workflows. By giving the installer the ability to read from `stdin`, we will enable a simplified workflow pattern via pipelines while still being capable of scaling with the complexity of users’ needs.

### Goals

Enable the Openshift Installer to support pipelined workflows by reading inputs from STDIN as an alternative to reading from the filesystem.

### Non-Goals

- Change the existing workflow to deploy an OpenShift cluster.
- Couple the Openshift Installer with Kustomize or other manifest tooling


## Proposal

Modify the OpenShift Installer to accept inputs from STDIN for all targets. For example: 

- Create manifests from customized install-config.yaml: `kustomize build github.com/myorg/myBlueprint/install-config-kustomization | openshift-install create manifests -f -`
- Create ignition files from customized set of manifests: `kustomize build ~/myBlueprint/01_manifests | openshift-install create ignition-configs -f -`
- Create cluster from customized set of manifests: `kustomize build ~/myBlueprint/01_manifests | openshift-install create cluster -f -`

The syntax and workflow will be similar to `oc apply -f -`.

A straight example of a use case is explained next. From Kustomize v3.7.0 it's possible to create reusable customizations called `Components`. Acording to this enhancement proposal the output of `openshift-install --kustomization create manifests` will generate the following structure in the chosen directory:

- openshift/
- manifests/
- kustomization.yaml (this file will list all manifests as resources)

The user wants to apply some remote overlay on top of the manifests generated by the installer. We would need to edit the generated kustomization.yaml with the following `components` section, build the result and create the cluster. A simplified workflow would look like:

```
TMPDIR=$(mktemp -d)
kustomize build https://github.com/myorg/myblueprint.git//install-config/ | openshift-install --kustomization create manifests -f - --dir=$TMPDIR
cat <<- EOF >> $TMPDIR/kustomization.yaml
components:                                                                                                                                                                                                     
- git::https://github.com/myorg/myblueprint.git//manifest-overlay/
EOF
kustomize build $TMPDIR | openshift-install create cluster -f -
```

The Kustomize `Component` can contain a set of patches that will overwrite certain parameters, or even add new manifests, resources, etc. To show one example, let's say we want to patch etcd service port. The files located in the remote Git repository will contain:

**kustomization.yaml**

```
apiVersion: kustomize.config.k8s.io/v1alpha1  # <-- Component notation
kind: Component

patches:
- etcd-service-port.yaml
- etcd-host-service-port.yaml
```

**etcd-service-port.yaml**
```
apiVersion: v1
kind: Service
metadata:
  name: etcd
  namespace: openshift-etcd
  labels:
    k8s-app: etcd
spec:
  ports:
    - $patch: replace
    - name: etcd
      port: 2378
      protocol: TCP
```

**etcd-host-service-port.yaml**
```
apiVersion: v1
kind: Service
metadata:
  name: host-etcd
  namespace: openshift-etcd
  labels:
    k8s-app: etcd
spec:
  ports:
    - $patch: replace
    - name: etcd
      port: 2378
      protocol: TCP
```


### User Stories

#### Story 1: Administrator persona

As an administrator, I want to deploy a set of nearly identical clusters by overlaying minimal changes to a base cluster definition using a simple pipelined CLI command. If I have to apply the same specific configuration on all my clusters, I need an easy way to apply it and deploy. I want to use kustomize or any other manifest manipulation tool and pipe the output to the OpenShift Installer. 

#### Story 2: Developer persona

As a developer, I want to customize the definition of a production cluster in order to deploy a copy in my test environment. In order to facilitate this task, It would help to have available a `kustomization.yaml` with a list of the manifest files generated by the installer.

### Implementation Details/Notes/Constraints

The installer would need to keying assets based on their type and name rather than their on-disk path. This approach does not fundamentally alter the design of the installer. It must also apply the existing validations on all of the assets as if they were provided via the filesystem.

#### Resources created by the installer

The `openshift-install create manifests` will create a kustomization.yaml file that will list the resources located in the openshift and the manifest directories if the flag `--kustomize` is passed. The content of the file should look like this:

```
resources:
- manifests/04-openshift-machine-config-operator.yaml
- manifests/cloud-provider-config.yaml
...
- openshift/99_cloud-creds-secret.yaml
- openshift/openshift-install-manifests.yaml
```

### Risks and Mitigations

The user might input non-valid manifests into the installer. That is why a set of validations shall be needed.

## Design Details


### Test Plan

### Graduation Criteria

Not applicable

### Upgrade / Downgrade Strategy

Not applicable

### Version Skew Strategy

Not applicable

## Implementation History

## Drawbacks

## Alternatives

